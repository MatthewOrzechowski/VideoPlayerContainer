//
//  TestMocks.generated.swift
//  Test
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import VideoPlayerContainer
import Foundation
import Mockingbird
import Swift
import VideoPlayerContainer
import XCTest

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked DependencyService
final class DependencyServiceMock: Test.DependencyService, Mockingbird.Mock {
  typealias MockingbirdSupertype = Test.DependencyService
  static let mockingbirdContext = Mockingbird.Context()
  let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Test"])

  enum InitializerProxy {
    static func initialize(_ `context`: VideoPlayerContainer.Context, __file: StaticString = #file, __line: UInt = #line) -> DependencyServiceMock {
      let mock: DependencyServiceMock = DependencyServiceMock(`context`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `fetchData`()
  override func `fetchData`() -> UInt64 {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`fetchData`() -> UInt64", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((UInt64).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> UInt64 { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`fetchData`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: UInt64 = mkbObject.`fetchData`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UInt64).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  func `fetchData`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> UInt64, UInt64> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> UInt64, UInt64>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`fetchData`() -> UInt64", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((UInt64).self)))
  }

  // MARK: Mocked init(_ `context`: VideoPlayerContainer.Context)
  required init(_ `context`: VideoPlayerContainer.Context) {
    super.init(`context`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(_ `context`: VideoPlayerContainer.Context)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`context`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  func initialize(_ `context`: @autoclosure () -> VideoPlayerContainer.Context) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (VideoPlayerContainer.Context) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (VideoPlayerContainer.Context) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(_ `context`: VideoPlayerContainer.Context)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`context`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(DependencyService.self).initialize(…)`.
func mock(_ type: Test.DependencyService.Type, file: StaticString = #file, line: UInt = #line) -> DependencyServiceMock.InitializerProxy.Type {
  return DependencyServiceMock.InitializerProxy.self
}

// MARK: - Mocked TargetService
final class TargetServiceMock: Test.TargetService, Mockingbird.Mock {
  typealias MockingbirdSupertype = Test.TargetService
  static let mockingbirdContext = Mockingbird.Context()
  let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Test"])

  enum InitializerProxy {
    static func initialize(_ `context`: VideoPlayerContainer.Context, __file: StaticString = #file, __line: UInt = #line) -> TargetServiceMock {
      let mock: TargetServiceMock = TargetServiceMock(`context`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `fetchDataFromDependency`()
  override func `fetchDataFromDependency`() -> UInt64 {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`fetchDataFromDependency`() -> UInt64", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((UInt64).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> UInt64 { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`fetchDataFromDependency`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: UInt64 = mkbObject.`fetchDataFromDependency`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UInt64).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  func `fetchDataFromDependency`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> UInt64, UInt64> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> UInt64, UInt64>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`fetchDataFromDependency`() -> UInt64", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((UInt64).self)))
  }

  // MARK: Mocked init(_ `context`: VideoPlayerContainer.Context)
  required init(_ `context`: VideoPlayerContainer.Context) {
    super.init(`context`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(_ `context`: VideoPlayerContainer.Context)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`context`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  func initialize(_ `context`: @autoclosure () -> VideoPlayerContainer.Context) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (VideoPlayerContainer.Context) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (VideoPlayerContainer.Context) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(_ `context`: VideoPlayerContainer.Context)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`context`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(TargetService.self).initialize(…)`.
func mock(_ type: Test.TargetService.Type, file: StaticString = #file, line: UInt = #line) -> TargetServiceMock.InitializerProxy.Type {
  return TargetServiceMock.InitializerProxy.self
}
